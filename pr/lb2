import os
import sys
import sqlite3
import hashlib
import base64
from Crypto.Cipher import AES
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Random import get_random_bytes
import argparse

# ---------- Database setup ----------
DB_PATH = "/home/shiza/Desktop/file_integrity.db"

def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS files (
                    filename TEXT PRIMARY KEY,
                    hash TEXT NOT NULL
                )''')
    conn.commit()
    conn.close()

# ---------- Hashing ----------
def compute_hash(file_path):
    sha256_hash = hashlib.sha256()
    with open(file_path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            sha256_hash.update(chunk)
    return sha256_hash.hexdigest()

# ---------- Integrity Functions ----------
def store_hash(filename, hash_value):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("REPLACE INTO files (filename, hash) VALUES (?, ?)", (filename, hash_value))
    conn.commit()
    conn.close()

def check_integrity(filename):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT hash FROM files WHERE filename=?", (filename,))
    row = c.fetchone()
    conn.close()

    if not row:
        print(f"‚ö†Ô∏è No stored hash found for {filename}. Please store it first using integrity-check.")
        return

    stored_hash = row[0]
    current_hash = compute_hash(filename)

    if stored_hash == current_hash:
        print(f"‚úÖ File integrity OK ‚Äî {filename} has not been tampered with.")
    else:
        print(f"‚ùå ALERT: {filename} has been modified or tampered!")

# ---------- Encryption ----------
def encrypt_file(file_path, password, output_path):
    salt = get_random_bytes(16)
    key = PBKDF2(password, salt, dkLen=32)
    cipher = AES.new(key, AES.MODE_GCM)
    with open(file_path, "rb") as f:
        plaintext = f.read()
    ciphertext, tag = cipher.encrypt_and_digest(plaintext)
    with open(output_path, "wb") as f:
        [f.write(x) for x in (salt, cipher.nonce, tag, ciphertext)]
    print(f"üîí File encrypted successfully ‚Üí {output_path}")

# ---------- Decryption ----------
def decrypt_file(file_path, password, output_path):
    try:
        with open(file_path, "rb") as f:
            salt, nonce, tag, ciphertext = [f.read(x) for x in (16, 16, 16, -1)]
        key = PBKDF2(password, salt, dkLen=32)
        cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
        plaintext = cipher.decrypt_and_verify(ciphertext, tag)
        with open(output_path, "wb") as f:
            f.write(plaintext)
        print(f"üîì File decrypted successfully ‚Üí {output_path}")
    except ValueError:
        print("‚ùå Decryption failed! The password may be incorrect o
